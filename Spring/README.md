# Spring

## 목차
- [스프링, 스프링부트](#jvm)
- [IoC와 Spring Bean](#java-1)
- [DI](#접근제어자)
- [AOP](#java-버전-별-특징)
- [Filter, Interceptor](#oop)
- [Lombok](#추상-클래스와-인터페이스)
- [@Transactional](#gcgarbage-collector)
- [Spring MVC](#thread-동기화)
- [Spring Security](#error-vs-exception)
- [DispatcherServlet](#generic)

## 스프링, 스프링부트

- **Spring이란 무엇인가요?**
    
    자바 어플리케이션 개발을 편리하게 해주는 오픈소스 애플리케이션 프레임워크입니다. 자바 객체의 생성, 소멸 등 라이프 사이클을 더욱 편리하게 관리할 수 있도록 해줍니다.
    
- **Spring과 SpringBoot의 차이는 무엇인가요?**
    
    가장 큰 차이점은 프로젝트 환경 설정 부분에 있다고 생각합니다. Spring은 프로젝트 초기에 다양한 환경설정을 해야 하지만, SpringBoot는 설정의 많은 부분을 자동화하여 개발자가 편하게 스프링 기반의 애플리케이션을 개발할 수 있도록 활용할 수 있도록 도와줍니다.
    
- **스프링 어노테이션 종류에 대해 아는대로 말해주세요.**
    - **@Controller**, **@RestController**: 컨트롤러 클래스를 정의합니다.
    - **@Service**: 서비스 레이어의 컴포넌트를 정의합니다.
    - **@Repository**: 데이터 레포지토리의 역할을 하는 클래스를 정의합니다.
    - **@Autowired**: 의존성 주입을 위해 사용됩니다.
    - **@RequestMapping**, **@GetMapping**, **@PostMapping** 등: HTTP 요청을 핸들링하는 메소드를 매핑합니다.
- **Mybatis란 무엇인가요?**
    
    SQL 문을 XML 혹은 어노테이션으로 관리하면서, 객체와 SQL 간의 매핑을 지원하는 퍼시스턴스 프레임워크입니다.
    
- **Mybatis, JPA 차이는 무엇인가요?**
    
    Mybatis와 JPA 차이: Mybatis는 SQL을 직접 작성하고 제어할 수 있는 반면, JPA는 객체 중심의 프로그래밍을 통해 데이터베이스 작업을 추상화합니다.
    
- **Spring JDBC란 무엇인가요?**
    
    스프링 프레임워크에서 제공하는 JDBC 추상화 레이어로, 데이터베이스 작업을 좀 더 쉽게 수행할 수 있게 해줍니다. 데이터베이스 테이블과, 자바 객체 사이의 단순한 매핑을 간단한 설정을 통해 처리할 수 있도록 해줍니다.
    
- **DAO, DTO란 무엇인가요?**
    - DAO(Data Access Object): 데이터베이스의 데이터에 접근하기 위한 객체로, 데이터베이스 CRUD 작업을 수행합니다.
    - DTO(Data Transfer Object): 계층 간 데이터 교환을 위한 객체로, 로직을 가지지 않는 순수한 데이터 객체입니다.
- **POJO란 무엇인가요?**
    
    POJO (Plain Old Java Object)는 가장 간단하고 일반적인 Java 객체를 의미합니다. 특정 기술, 프레임워크, 프로토콜에 종속되지 않는, 가벼운 객체를 말하며, POJO는 확장성과 유연성을 제공하며, 테스트와 유지보수가 용이합니다.
    
    진정한 POJO란 객체지향적 원리에 충실하면서, 환경과 기술에 종속되지 않고, 필요에 따라 재활용할 수 있도록 설계된 객체입니다.
    

## IoC와 Spring Bean

- **IoC란?**
    
    IoC란 Inversion of Control의 약자로, 제어의 역전을 의미합니다. 모든 객체의 라이프사이클 제어권을 개발자가 아닌 IoC 컨테이너가 가지고 있는 것을 말합니다.
    
    제어권이 스프링으로 프레임워크로 넘어오게 되면서, DI(의존성 주입), AOP(관점 지향 프로그래밍) 등이 가능해 집니다.
    
- **Spring Bean이란 무엇인가요?**
    
    스프링 IoC 컨테이너가 관리하는 객체를 의미합니다. 이 객체들은 스프링의 의존성 주입 기능을 통해 생성되고 관리됩니다.
    
- **스프링 IoC 컨테이너란 무엇인가요?**
    
    스프링에서 객체를 생성하고 의존성을 관리해주는 컨테이너입니다. 컨테이너가 관리하는 객체를 빈이라고 하는데 이 빈을 관리한다는 의미로 빈팩토리(BeanFactory)라고 부르기도 합니다.
    
- **객체의 생명주기를 IoC 컨테이너가 함으로써 얻는 장점에는 무엇이 있나요?**
    - 개발자는 비즈니스 로직에 집중할 수 있고, 객체 생성 코드가 없으므로 TDD가 용이합니다.
- **후보 없이 특정 기능을 하는 클래스가 딱 한 개라면, 구현체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?**
    
    후보 없이 특정 기능을 하는 클래스가 하나뿐일 때 직접 사용해도 기술적으로 문제는 없습니다. Spring에서 Bean을 사용하는 이유는 유연성, 테스트 용이성, 일관된 관리 등을 위함입니다. Bean을 사용하면 나중에 다른 구현으로 교체하거나, 확장성을 높이는 등의 이점을 얻을 수 있습니다.
    
- **BeanFactory와 ApplicationContext의 차이점에 대해 알고 계신가요?**
    - BeanFactory란 단순히 컨테이너에서 객체를 생성하고 DI를 처리하는 기능을 제공합니다. 팩토리패턴으로 구현되어있습니다. 보통은 BeanFactory를 사용하지 않고 이를 확장한 ApplicationContext를 사용합니다.
    - ApplicationContext란 빈팩토리에 각종 부가 기능을 추가로 제공합니다. 텍스트 메시지를 관리하거나, 이미지 파일 로드, 리스너로 등록된 빈에게 이벤트 발생을 알려주는 등의 기능을 제공합니다.
- **스프링 빈을 등록하는 방법에는 어떤 것이 있나요?**
    
    스프링에서 빈을 등록하는 방법은 2가지가 있습니다.
    
    1. **컴포넌트 스캔을 통한 자동 의존관계 설정(@Component)**
        1. 빈으로 등록하길 원하는 클래스에 @Component 어노테이션을 사용합니다. **@Controller, @Service, @Repository**는 모두 **@Component를 포함**하고 있으며, 해당 어노테이션으로 등록된 클래스들은 스프링 컨테이너에 의해 자동으로 생성되어 **스프링 빈으로 등록**됩니다.
    2. **수동으로 스프링 빈 등록(@Bean)**
        1. @Configuration 어노테이션이 적힌 설정 클래스를 만들고,
        2. 특정 타입을 리턴하는 메소드를 만들고 이 메소드에 @Bean을 붙여주면 자동으로 해당 타입의 빈 객체가 생성됩니다.
        3. @Bean이 붙은 메소드의 리턴 객체는 스프링 빈으로 등록되고, 빈의 이름은 메소드의 이름이 됩니다.
- **Bean의 Scope는 어떤 종류가 있으며 각각의 차이점은 무엇인가요?**
    - **Singleton**: 기본 스코프로, 컨테이너당 하나의 인스턴스만 생성됩니다.
    - **Prototype**: 요청될 때마다 새로운 인스턴스를 생성합니다.
    - **Request**: HTTP 요청당 하나의 인스턴스를 생성합니다. 웹 어플리케이션에 주로 사용됩니다.
    - **Session**: HTTP 세션당 하나의 인스턴스를 생성합니다.
    - **Global-Session**: 글로벌 HTTP 세션당 하나의 인스턴스를 생성합니다. 포털 어플리케이션에서 사용됩니다.
- **Spring Bean의 생명주기에 대해 설명해 주세요**
    
    <aside>
    💡 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → **의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출** → 스프링 종료
    
    </aside>
    
    - **인스턴스화**: Bean 정의에 따라 인스턴스가 생성됩니다.
    - **속성 설정**: 의존성과 속성이 Bean에 주입됩니다.
    - **초기화**: 사용자 정의 초기화 메소드나 **InitializingBean** 인터페이스의 **afterPropertiesSet** 메소드를 통해 초기화 과정이 진행됩니다.
    - **사용**: Bean이 사용됩니다.
    - **소멸**: 컨테이너가 종료될 때 **DisposableBean** 인터페이스의 **destroy** 메소드나 사용자 정의 소멸 메소드를 통해 소멸 과정이 진행됩니다.
- **프로토타입 빈은 무엇인가요?**
    - 프로토타입 빈은 매번 요청 시마다 새로운 인스턴스를 생성합니다.
    - 싱글톤 빈과 달리 각 요청마다 고유한 인스턴스가 생성되므로, 상태를 유지하지 않는 빈에 적합합니다.
- **DI와 DL에 대해 알고 계신가요?**
    - DL이란 Dependency Lookup의 약자로, 저장소에 저장되어 있는 빈에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 빈을 Lookup 하는 것을 의미합니다.
    - DI이란 Dependency Injection의 약자로, 객체 간 의존관계를 빈 설정 정보를 바탕으로 스프링 IoC 컨테이너가 자동으로 연결해주는 것을 의미합니다.

## DI

- **DI란?**
    
    DI는 Dependency Injection의 약자로, 의존성 주입을 의미합니다. 객체의 의존성(다른 객체에 대한 참조)을 외부에서 주입하는 것을 말합니다. 각 클래스간의 의존관계를 빈 설정 정보를 바탕으로 외부 컨테이너에서 주입합니다. 이를 통해 객체 간의 결합도를 낮추고, 유연성과 테스트 용이성을 향상시킵니다.
    
- @Autowired annotation은 무엇을 의미하며 어떻게 작동하는지 설명해주세요.
    - **@Autowired**는 스프링 프레임워크에서 의존성 주입(Dependency Injection)을 자동으로 처리하기 위한 애너테이션입니다.
    - 이 애너테이션은 스프링 컨테이너에 의해 관리되는 빈(Bean)을 자동으로 연결합니다. 스프링 컨테이너는 **@Autowired**가 붙은 필드, 생성자, 또는 메소드에 해당하는 타입의 빈을 찾아서 주입합니다.
    - 타입에 의한 자동연결이 주요 메커니즘으로, 동일한 타입의 빈이 컨테이너에 존재하면 그 빈을 해당 필드에 주입합니다.
- @Autowired를 사용하여 의존성을 주입하는 방식은 어떤 것들이 있고, 각각의 차이점은 무엇인지 설명해주세요.
    - 필드 주입(Field Injection): 클래스의 필드에 직접 **@Autowired**를 사용합니다. 간결하지만, 클래스가 스프링에 강하게 의존하게 되며, 테스트가 어려울 수 있습니다.
    - 생성자 주입(Constructor Injection): 클래스의 생성자에 **@Autowired**를 사용합니다. 의존성이 명확하게 드러나며, 불변성과 테스트 용이성을 제공합니다.
    - 세터 주입(Setter Injection): 세터 메소드에 **@Autowired**를 사용합니다. 선택적 의존성을 제공하고, 런타임에 의존성을 변경할 수 있습니다.
- **DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?**
    - 생성자 주입(Constructor Injection): 의존성을 클래스 생성자를 통해 주입합니다. 가장 권장되는 방식입니다.
        - **클래스의 생성자가 하나이고, 그 생성자로 주입받을 객체가 빈으로 등록되어 있다면** @Autowired를 생략 할 수 있습니다.
    - 필드 주입(Field Injection): 직접 필드에 의존성을 주입합니다.
        - 클래스가 스프링에 대한 의존도가 높아지고 테스트가 어려워질 수 있습니다.
    - 세터 주입(Setter Injection): 세터 메소드를 통해 의존성을 주입합니다. 선택적인 의존성 관리에 적합합니다.
        - 그러나 set 메서드를 public으로 열어두어야 합니다.
    - 메소드 주입(Method Injection): 일반 메소드를 통해 의존성을 주입합니다. 드물게 사용되며, 특정한 경우에 유용할 수 있습니다.
- **생성자 주입을 권장하는 이유는 무엇인가요?**
    - **순환 참조 방지**: 필드주입과 수정자주입은 빈이 생성된 이후에 참조를 하기 때문에 순환참조를 발견할 수 없습니다. 그러나 생성자 주입을 하면 BeanCurrentlyInCreationException이 발생하여 오류 체크를 할 수 있습니다.
    - **불변성**: 생성자로 의존성을 주입하면 final로 선언되어 변경할 수 없으므로, 더 안전한 코드를 작성할 수 있습니다. 하지만 수정자 주입이나 메소드 주입을 이용하면 수정의 가능성을 열어두는 것이므로 OOP 중 개방폐쇄원칙(OCP)을 위반하게 됩니다.
    - 명확성: 필요한 의존성이 명확하게 드러나므로, 클래스의 의존성을 쉽게 파악할 수 있습니다.
    - 테스트 용이성: 생성자 주입을 사용하면, 테스트 코드에서 필요한 의존성을 쉽게 주입할 수 있습니다.
- **생성자 주입과 필드/수정자주입 사이의 의존성 주입 과정 차이점에 대해 알고 계신가요?**
    - 생성자 주입은 객체의 생성과 의존관계 주입이 동시에 일어나는 반면
    - 필드주입이나 수정자주입은 객체의 생성이 먼저 일어나고, 그 후 의존관계 주입이 일어납니다.
- **생성자 주입은 왜 객체의 생성과 의존관계 주입이 동시에 일어날까요?**
    - 해당 클래스를 생성하기 위해 필요한 객체가 존재하지 않는다면 그 클래스는 생성이 불가능하기 때문입니다.
- **빈 생성과 초기화 또한 동시에 진행하면 안될까요?**
    
    객체의 생성과 초기화는 분리하는 것이 좋습니다. 이는 두 과정에서의 책임을 분리하기 때문입니다.
    
    생성자는 필수 정보를 받아 메모리를 할당하고 객체를 생성하는 책임을 가지는 반면, 초기화는 생성된 값들을 활용해 다른 작업들을 수행합니다. 따라서 이 두 과정을 묶는 것은 SRP(단일책임원칙)에 위배되기도 하고, 명확하게 두 부분으로 나누는 것이 유지 보수 관점 및 객체지향 프로그램적으로도 좋습니다.
    

## AOP

- **AOP에 대해 설명해 주세요.**
    
    스프링은 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원합니다.
    
    트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있습니다. 주로 인증, 로깅, 트랜잭션 처리 등에 사용됩니다.
    
- **AOP 용어 설명**
    1. **타겟 (Target):**
        - 부가기능을 부여할 대상
    2. **어드바이스 (Advice)**:
        - **개념**: 어드바이스는 AOP에서 실제로 수행되는 작업(로직)을 정의합니다. 이는 특정 조인 포인트(예: 메서드 호출, 필드 접근)에서 실행되는 코드입니다.
        - **유형**: Before, After, After-returning, After-throwing, Around 등 여러 유형의 어드바이스가 있으며, 각각은 메서드 실행의 특정 시점에 동작합니다.
    3. **포인트컷 (Pointcut)**:
        - **개념**: 포인트컷은 어드바이스가 적용될 조인 포인트(예: 특정 메서드, 클래스)를 정의합니다. 이는 어드바이스를 어떤 메서드에 적용할지를 결정하는 패턴 또는 식입니다.
        - **사용**: 포인트컷 표현식을 통해, 어드바이스가 적용될 메서드의 시그니처를 정의합니다.
    4. **애스펙트 (Aspect)**:
        - **개념**: 애스펙트는 포인트컷과 어드바이스를 결합한 모듈입니다. 애스펙트는 어떤 로직(어드바이스)이 어디에(포인트컷) 적용될지를 정의합니다.
        - **예시**: 로깅, 트랜잭션 관리 등 공통 기능을 애스펙트로 정의하고, 여러 컴포넌트에 걸쳐 적용할 수 있습니다.
    5. **Weaving:**
        1.  Advice를 핵심 로직코드에 적용하는 것
- **AOP를 사용하면 어떤 점이 좋은가요?**
    - 여러 클래스에서 중복되는 코드를 제거할 수 있습니다.
    - 공통된 모듈을 분리함으로써 재활용성이 극대화됩니다.
- **스프링부트에서 AOP를 적용하는 과정을 설명해주세요.**
    1. 의존성 추가: 우선 spring aop를 사용하기 위해 의존성을 추가합니다.
    2. @EnableAspectJAutoProxy 어노테이션을 통해 AOP를 활성화합니다.
    3. Aspect 클래스를 작성합니다. @Aspect 어노테이션을 추가하고, 빈으로 등록하기 위해 @Component 어노테이션을 추가합니다.
        1. 각 어드바이스가 실행될 포인트컷을 명시합니다.
        2. 어드바이스의 로직을 작성합니다.
- **프로젝트에서 AOP를 사용해보신 경험이 있으신가요?**
    - Service 레이어에서 Transactional 어노테이션을 통한 트랜잭션 기능을 사용했습니다.

## Filter, Interceptor

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f4f15baa-7517-4a1f-9ede-608a4bd3a955/458c03e5-0f33-478e-ac6c-6bacce676b34/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f4f15baa-7517-4a1f-9ede-608a4bd3a955/89e12b5b-c1ba-409c-8212-3d9a4b491e9c/Untitled.png)

- **필터에 대해 설명해주세요.**
    
    필터는 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리되고, 스프링 범위 밖에서 처리됩니다. **Dispatcher Servlet에 요청이 전달되기 전/후**에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공합니다.
    
    - 보안 및 인증/인가 관련 작업
    - 모든 요청에 대한 로깅 또는 검사
    - 이미지/데이터 압축 및 인코딩
- **인터셉터에 대해 설명해주세요.**
    
    인터셉터는 요청에 대한 작업 전/후에 요청과 응답을 참조하거나 가공하는 역할을 합니다. 인터셉터는 필터와 달리 스프링 컨텍스트에서 동작합니다. Dispatcher Servlet이 controller를 호출하기 전/후에 인터셉터가 작동합니다.
    
    - 세부적인 보안 및 인증/인가 공통 작업
    - API 호출에 대한 로깅 또는 검사
    - Controller로 넘겨주는 데이터의 가공
- **필터, 인터셉터, AOP는 왜 생겨났나요?**
    
    개발을 하다 보면 공통으로 처리해야 할 로직들이 많은데, 이 부분에 대한 코드를 페이지마다 작성한다면 중복 코드가 많아지게 되고 유지 보수성 측면에서 좋지 않습니다. 따라서 Spring은 공통으로 여러 작업을 처리하여 중복된 코드를 제거할 수 있는 기능을 제공하고 있습니다.
    
    1. Filter(필터)
    2. Interceptor(인터셉터)
    3. AOP(Aspect Oriented Programming, 관점 지향 프로그래밍)
- **필터와 인터셉터의 공통점에 대해 설명해주세요.**
    - 필터와 인터셉터 모두 비즈니스 로직과 분리되어 특정 요구사항을 만족해야 할 때 적용합니다. 보안, 인증, 인코딩 등의 요구사항이 있습니다.
- **필터와 인터셉터의 차이점에 대해 설명해주세요.**
    1. **관리되는 컨테이너의 차이**
        - 필터는 웹 컨테이너에 의해, 인터셉터는 스프링 컨테이너에 의해 관리됩니다.
    2. **Request, Response 객체 조작 가능 여부**
        1. 필터는 Request, Response를 조작할 수 있지만 인터셉터는 조작할 수 없습니다.
        2. 필터는 다음 필터 호출시 request, response를 넣어주고, 인터셉터는 true/false만 반환할 수 있습니다.
        3. 필터가 다음 필터를 호출할 때 request, response 객체를 넘겨주기 때문에 중간에 객체의 변경이 가능합니다.
        4. 그러나 인터셉터는 Dispatcher Servlet이 여러 인터셉터 목록을 가지고 있고, 이를 순차적으로 실행시킵니다. 이때 인터셉터가 true를 반환하면 다음 인터셉터가 실행되고, false를 반환하면 요청이 중단됩니다. 그러므로 중간에 다른 객체를 넣어줄 수 없습니다.
    3. 사용 사례에서의 차이점
        - **필터 사용**: 특정 요청이나 컨트롤러에 관계없이 애플리케이션에 들어오는 모든 요청에 대해 전역적인 처리가 필요한 경우 사용합니다. 예를 들어, 인코딩 변환, CORS 설정, 보안 검사 등이 있습니다.
        - **인터셉터 사용**: 클라이언트 요청과 관련된 작업에 추가적인 요구사항을 만족해야 할 때 적용합니다.
    
    필터와 인터셉터는 스프링에서 HTTP 요청을 처리하는 방법으로 사용됩니다. 필터(Filter)는 서블릿 레벨에서 요청과 응답을 가로채어 로깅, 인증 등의 기능을 수행합니다. 반면, 인터셉터(Interceptor)는 스프링의 컨트롤러 실행 전후에 작동합니다. 핸들러 매핑, 컨트롤러 호출 등 스프링 컨텍스트 내에서 좀 더 세밀한 작업을 수행할 수 있습니다.
    
- **인터센터와 AOP의 비교**
    - AOP의 Advice들은 메소드의 전후 지점에 자유롭게 설정할 수 있습니다.
    - Interceptor와 Filter는 주소(URL)로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 애노테이션 등 PointCut이 지원하는 다양한 방법으로 대상을 지정할 수 있습니다.

## Lombok

- **Lombok 메소드들이 생성되는 시점은 언제인가요?**
    
    롬복은 어노테이션 프로세싱을 통해 자바 컴파일러가 메소드를 컴파일하는 과정에 개입하여 코드를 만들어냅니다. 그렇기 때문에 롬복 라이브러리를 추가할 때 CompileOnly, AnnotationProcessor도 함께 추가해야 합니다.
    
- **Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?**
    - **@Data** 어노테이션은 getter, setter, **equals()**, **hashCode()**, **toString()** 메소드를 자동으로 생성합니다.
    - **사용하지 않는 이유**:
        - **객체의 불변성 문제**: **@Data**는 setter를 생성하여 객체의 불변성을 해칠 수 있습니다. 불변 객체를 선호하는 경우에는 적합하지 않습니다.
        - **자동 생성된 메소드의 부작용**: **equals()**와 **hashCode()** 메소드가 자동 생성되면, 예상치 못한 방식으로 작동할 수 있으며, 성능 문제를 일으킬 수 있습니다.
        - **디버깅의 어려움**: 자동 생성된 코드는 디버깅 시 추적하기 어렵습니다.
        - **명시성 감소**: 코드의 명시성이 감소하여, 프로젝트의 다른 개발자가 코드를 이해하기 어려울 수 있습니다.

## @Transactional

- **@Transactional의 동작 원리에 대해 설명해주세요.**
    
    @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 **Proxy 객체**가 생성되며, Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행합니다.
    
- **@Transactional를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드 B가 호출되었을 때, B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명해주세요.**
    - **프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작**하며, 타겟 객체의 메소드가 자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않습니다.
    - 즉, A 메소드는 프록시로 감싸진 메소드가 아니므로 **트랜잭션이 적용되지 않은** 일반 코드가 수행됩니다.
- **@Transactional에 readOnly 속성을 사용하는 이유에 대해서 설명해주세요.**
    
    트랜잭션 안에서 수정/삭제 작업이 아닌 **ReadOnly 목적인 경우에 주로 사용**하며, 영속성 컨텍스트에서 엔티티를 관리 할 필요가 없기 때문에 readOnly를 추가하는 것으로 **메모리 성능을 높일 수 있고,** 데이터 변경 불가능 로직임을 코드로 표시할 수 있어 가독성이 높아진다는 장점이 있습니다.
    
- **@Transactional에 readOnly 속성을 사용하지 않으면 어떻게 되나요?**
    
    readOnly 속성이 없는 보통의 트랜잭션은 데이터 조회 결과 엔티티가 영속성 컨텍스트에 관리되며, 이는 1차 캐싱부터 변경 감지(Dirty Checking)까지 가능하게 됩니다.
    
    하지만, 조회시 스냅샷 인스턴스를 생성해 보관하기 때문에 메모리 사용량이 증가합니다.
    

## Spring MVC

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f4f15baa-7517-4a1f-9ede-608a4bd3a955/ea162400-555d-45e0-8acc-502c6cc37eba/Untitled.png)

- **Spring MVC에 대해 설명해주세요.**
    
    MVC는 Model, View, Controller의 약자로서, 각 레이어간 기능을 구분하여 개발하는 디자인 패턴입니다.
    
    - **Model**은 데이터 관리 및 비즈니스 로직을 처리하는 부분으로, DTO, Service등이 속합니다.
    - **View**는 비즈니스 로직 처리 결과를 통해 유저 인터페이스가 표현되는 부분으로, html 등으로 화면 자체가 될 수도 있고 REST API로 서버가 구현된다면 json 응답이 되기도 합니다.
    - **Controller**는 사용자의 요청을 처리하고 Model과 View를 중개하는 역할을 합니다.
- **Spring MVC 구조와 처리과정에 대해 설명해주세요.**
    1. **DispatcherServlet** : 어플리케이션으로 들어오는 모든 Request를 받는 관문입니다. `Request`를 실제로 처리할 `Controller에게 전달`하고 그 결과값을 받아서 View에게 전달하여 적절한 응답등 생성할 수 있도록 흐름을 제어한다.
    2. **HandlerMapping** : `Request URL` 각각을 어떤 `Controller`가 실제로 처리할 것인지 **찾아주는 역할**을 합니다.
    3. **Controller** : Request를 **직접 처리한 후** 그 결과를 다시 **DispatcherServlet 에게 돌려줍니다**.
    4. **ModelAndView** : Controller가 처리한 결과와 그 결과를 보여줄 View에 관한 정보를 담고 있는 객체입니다.
    5. **ViewResolver** : View 관련 정보를 갖고 실제 **View를 찾아주는 역할**을 합니다.
    6. **View** : Controller가 처리한 결과값을 보여줄 **View를 생성**합니다.
    
    <정리>
    
    우선, 디스패처 서블릿이 클라이언트로부터 요청을 받으면, 이를 요청할 핸들러 이름을 알기 위해 핸들러맵핑에게 물어봅니다.
    
    핸들러맵핑은 요청 url을 보고 핸들러 이름을 디스패처 서블릿에게 알려줍니다. 이때 핸들러를 실행하기 전/후에 처리할 것들을 인터셉터로 만들어 줍니다.
    
    디스패처 서블릿은 해당 핸들러에게 제어권을 넘겨주고, 이 핸들러는 응답에 필요한 서비스를 호출하고 렌더링해야 하는 뷰 이름을 판단하여 디스패처 서블릿에게 전송해줍니다.
    
    디스패처 서블릿은 받은 뷰 이름을 뷰 리졸버에게 전달해 응답에 필요한 뷰를 만들라고 명령합니다.
    
    이때 해당하는 뷰는 디스패처 서블릿에게 받은 모델과 컨트롤러를 활용해 원하는 응답을 생성해서 다시 보내줍니다.
    
    디스패처 서블릿은 뷰로부터 받은 것을 클라이언트에게 응답해줍니다.
    
- **MVC 1과 MVC 2의 차이**
    - MVC 1: 모델, 뷰, 컨트롤러가 하나의 객체에 통합된 구조입니다. 비즈니스 로직과 프레젠테이션 로직이 섞여 있을 수 있습니다. JSP페이지 안에서 로직 처리를 위해 자바 코드가 함께 사용됩니다. 구조가 단순한 장점이 있지만, JSP 내에서 html 코드와 자바 코드가 같이 사용되면서 복잡해지고 유지보수가 어려운 단점이 있습니다.
    - MVC 2: 모델, 뷰, 컨트롤러가 명확하게 분리되어 있습니다. 각각 독립적으로 역할을 수행하여 유지보수와 확장성이 더 좋습니다.

## Spring Security

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f4f15baa-7517-4a1f-9ede-608a4bd3a955/2a4fb9eb-490e-4947-8f91-ed5252c33dfa/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f4f15baa-7517-4a1f-9ede-608a4bd3a955/87d367ed-62fa-4a16-9192-60802aa12890/Untitled.png)

- **Spring security가 무엇인가요?**
    
    Spring Security는 스프링 기반의 애플리케이션에 대한 보안(인증 및 권한 부여)을 제공하는 프레임워크입니다. 주로 웹 보안을 위해 사용되며, 사용자 인증(Authentication)과 인가(Authorization) 기능을 제공합니다.
    
- **인증(Authentication)과 인가(Authorization)의 차이점에 대해 설명해주세요.**
    - 인증이란 유저가 누구인지 확인하는 절차로서, 회원가입하고 로그인 하는 것을 말합니다.
    - 인가란 유저에 대한 권한을 허락하는 것으로, 해당 유저에게 요청에 대한 권한이 있는지 확인하는 절차입니다.
- **Spring security는 스프링의 어디에 위치하나요?**
    
    Spring Security는 스프링의 DispatcherServlet 앞단에 Filter 형태로 위치합니다. Dispatcher로 넘어가기 전에 이 Filter가 요청을 가로채서, 클라이언트의 리소스 접근 권한을 확인하고, 없는 경우에는 인증 요청 화면으로 자동으로 리다이렉트합니다.
    
- **Spring Security 인증은 어떻게 이루어지나요?**
    
    사용자가 로그인 정보와 함께 인증 요청(HttpRequest)을 하면 AuthenticationFilter가 요청을 가로채고 가로챈 정보를 통해 UsernamePasswordAuthenticationToken(인증용 객체)를 만들고 이를 이용해 AuthenticationManager의 인증 메서드를 호출한다. 이후 UserDetailsService 구현체를 통해 DB에 저장된 정보와 비교해 일치하면 UserDetails 구현 객체를 반환해 SecurityContext에 저장한다.
    
- **Spring Security 사용을 위한 설정 파일은 어떻게 만드나요?**
    
    ```java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
    	  http
          .httpBasic().disable() // rest api 이므로 기본설정 사용안함. 기본설정은 비인증시 로그인폼 화면으로 리다이렉트
          .cors().configurationSource(corsConfigurationSource())
          .and()
          .csrf().disable() // rest api이므로 csrf 보안이 필요없으므로 disable처리.
          .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // jwt token으로 인증하므로 세션은 필요없으므로 생성안함.
          .and()
          .authorizeRequests() // 다음 리퀘스트에 대한 사용권한 체크
          .antMatchers("/*/signin", "/*/signin/**", "/*/signup", "/*/signup/**", "/social/**").permitAll() // 가입 및 인증 주소는 누구나 접근가능
          .antMatchers(HttpMethod.GET, "home/**").permitAll() // home으로 시작하는 GET요청 리소스는 누구나 접근가능
          .anyRequest().hasRole("USER") // 그외 나머지 요청은 모두 인증된 회원만 접근 가능
          .and()
          .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class); // jwt token 필터를 id/password 인증 필터 전에 넣는다
    
    }
    ```
    

## DispatcherServlet

- **디스패처 서블릿이란?**
    
    디스패처 서블릿은 Spring MVC의 핵심 요소로, 들어오는 모든 요청을 취합하여 요청을 적절한 핸들러(컨트롤러)에 전달하고, 핸들러의 실행 결과를 HTTP 응답으로 변환하는 역할을 수행합니다.
    
- **디스패처 서블릿으로 인한 web.xml 역할 축소에 대해 설명해주세요.**
    
    스프링의 디스패처 서블릿 도입으로, 전통적인 web.xml 파일의 역할이 축소되었습니다. 많은 설정들이 자바 기반의 설정으로 이동하면서 더 유연하고 간결한 설정이 가능해졌습니다.
    
- **DispatcherServlet과 Front Controller 패턴의 관계에 대해 설명해주세요.**
    - **DispatcherServlet**은 Front Controller 디자인 패턴의 구현체입니다.
    - 이 패턴의 목적은 모든 요청을 단일 진입점으로 처리하여 시스템의 복잡성을 줄이고 중복을 방지하는 것입니다. **DispatcherServlet**은 이 패턴을 통해 모든 요청을 한 곳에서 관리하여 요청 처리의 일관성과 관리 용이성을 제공합니다.
- **DispatcherServlet의 동작 과정을 설명해주세요.**
    - HTTP 요청이 들어오면 **DispatcherServlet**은 요청에 맞는 핸들러를 찾기 위해 **HandlerMapping**을 사용합니다.
    - 핸들러가 결정되면, **DispatcherServlet**은 해당 핸들러를 실행하기 위해 적절한 **HandlerAdapter**를 찾습니다.
    - 핸들러 실행 후, 반환된 모델 및 뷰 정보를 바탕으로 응답을 생성하고, 클라이언트에게 전송합니다.
- **HandlerMapping과 HandlerAdapter의 역할은 무엇인가요? DispatcherServlet과 어떻게 협력하나요?**
    - **HandlerMapping**: 요청 URL을 기반으로 해당 요청을 처리할 핸들러(Controller)를 결정합니다.
    - **HandlerAdapter**: **DispatcherServlet**이 다양한 타입의 컨트롤러를 동일한 방식으로 처리할 수 있게 해주는 어댑터 역할을 합니다.
    - **DispatcherServlet**은 **HandlerMapping**을 통해 요청에 적합한 핸들러를 찾고, **HandlerAdapter**를 사용하여 해당 핸들러를 실행합니다.
- **여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?**
    - **DispatcherServlet**은 멀티스레드 환경에서 동작하며, 동시에 여러 요청을 처리할 수 있습니다. 각 요청은 별도의 스레드에서 처리되므로, 한번에 여러 요청을 동시에 처리하는 것이 가능합니다.
- **수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?**
    - 각 **@Controller**는 특정 URL 경로나 요청에 대해 응답하도록 설정됩니다 (예: **@RequestMapping** 어노테이션을 통해). **DispatcherServlet**은 **HandlerMapping**을 사용하여 요청 URL과 매핑되는 적절한 **@Controller**를 찾아내어 요청을 처리합니다. 이렇게 URL 경로나 요청의 특성에 따라 각각의 컨트롤러를 구분하고 적절한 컨트롤러로 요청을 전달합니다.
