# Java
## 목차
- [JVM](##JVM)
- [JAVA](##JAVA)
- [접근제어자](##접근제어자)
- [Java 버전 별 특징](##JAVA-버전-별-특징)
- [OOP](##OOP)
- [추상 클래스와 인터페이스](##추상-클래스와-인터페이스)
- [GC(Garbage Collector)](##GC(Garbage-Collector))
- [Thread, 동기화](##Thread,-동기화)
- [Error vs Exception](##Error-vs-Exception)
- [Generic](##Generic)
- [불변객체](##불변객체)
- [Composition (컴포지션)](##Composition-(컴포지션))
- [Stream](##Stream)


## JVM

- **JVM이란 무엇인가요?**
  - JVM이란 자바 가상 머신의 약자로, 컴퓨터가 자바 바이트 코드를 운영체제에 맞게 실행하도록 하는 역할을 수행합니다. OS의 종류에 상관없이 자바 파일을 실행할 수 있도록 해주기 때문에 자바 언어가 플랫폼 독립적인 특성을 가집니다.
- **JVM은 어떤 기능을 수행하나요?**
  - 바이트 코드 해석 및 실행
  - 메모리 관리 및 가비지 컬렉션(Garbage Collection)
  - 예외 처리
  - 다중 스레드 관리
  - 클래스 로딩과 동적 클래스 생성
- **JVM의 동작과정을 설명해주세요.**
  1. 프로그램이 실행되면 JVM은 OS로부터 필요한 메모리를 할당받습니다.
  2. 자바 컴파일러가 자바 소스코드를 읽어들여, 자바 바이트 코드(class 파일)로 변환합니다.
  3. Class Loader가 class 파일들을 JVM으로 로딩합니다.
  4. 로딩된 클래스 파일들은 실행 엔진과 Runtime Data Area를 통해 실행됩니다.
- **JVM의 메모리 구조에 대해 설명해주세요.**

  - JVM의 Runtime Data Area(런타인 데이터 영역)은 JVM이 OS로부터 할당받은 메모리 공간을 말하는데, 크게 5가지로 나눌 수 있습니다.
    - 1. 정적 메서드 영역: 스레드 간 공유되는 메모리 영역으로, 클래스/인터페이스/필드/메소드/static변수 등 바이트 코드를 보관합니다.
      - 클래스가 로딩될 때 생성됩니다.
      - 클래스, 변수, 메소드 정보
      - static 변수
      - Constant pool - 문자 상수, 타입, 필드, 객체참조가 저장됨
    - 2. Heap 영역: 스레드 간 공유되는 메모리 영역으로, 클래스의 인스턴스 및 배열에 대한 메모리가 할당되는 영역입니다. 또한 가비지 컬렉션의 대상이 되는 공간이기도 합니다.
      - 런타임시 할당됩니다.
      - new 키워드로 생성되는 객체와 배열이 저장되는 영역입니다.
    - 3. JVM Stack 영역: 각 스레드 별로 생성되는 메모리 영역으로, 로컬변수와 메서드 호출 정보 등을 저장합니다.
      - 컴파일 타임시 할당됩니다.
      - Heap 영역에 생성되는 객체의 주소 값을 가지고 있습니다.
      - 힙과 스택은 같은 메모리 공간을 동적으로 공유하며, 과도하게 사용하는 경우 OOM(Out Of Memory)이 발생할 수 있습니다.
    - 4. PC 레지스터: 현재 스레드의 실행 주소가 담기는 영역입니다.
      - 스레드가 생성될 때마다 생성되는 영역으로 다음 명령어의 주소를 알고 있습니다.
    - 5. 네이티브 메서드 스택: Java 코드가 아닌 다른 언어로 된 코드를 실행할 때 사용되는 메모리 영역입니다.

- **클래스로더의 클래스 로드 과정을 설명해주세요.**
  클래스 로드 과정은 크게 3단계로 나뉩니다.
  1. 로딩: .class 파일을 JVM 메모리에 로드하는 것
  2. 링킹: 크게 3가지 단계로 나뉨
     1. 1. 검증: 바이트 코드가 제대로 자바의 규칙을 따르고 있는지 검증
     2. 2. 준비: 클래스가 필요로 하는 메모리 양을 미리 할당
     3. 3. 분석: 클래스가 참조하는 객체에 대해 실제 메모리 주소 값을 대입
  3. 초기화: 클래스 안에 있는 static 변수의 값을 할당하고 초기화
- **클래스로더에게 클래스 로딩 요청이 왔을 때 동작 과정을 설명해주세요.**
  - 클래스를 올려달라는 요청을 받으면
    - 1. 해시에 해당 클래스가 있는지 확인
    - 2. 상위 클래스 로더에서 해당 클래스가 있는지 확인
    - 3. 본인 클래스 로더에서 가져옴
- **클래스 로더의 위계 순서를 알고 계신가요?**
  - Bootstrap Class Loader
    - JVM 실행 시 가장 먼저 실행됨
    - 자바의 기본적인 클래스 로드
  - Extension CL
    - 자바 기본 클래스 제외한 확장 클래스 로드
  - System CL
    - 자바 실행 시 classpath 에 정의된 클래스들 로드
  - User Defined CL
    - 유저가 직접 클래스 로더를 정의하여 사용할 수 있음
- **컴파일러와 인터프리터의 차이는?**
  둘의 가장 큰 차이는 **목적 프로그램을 생성하느냐, 안하느냐**라고 할 수 있습니다. 컴파일러는 말 그대로 고수준 언어를 저수준 언어로 변환하는 도구입니다. 컴파일러를 통해 소스코드를 전부 컴파일해서 하나의 실행 가능한 프로그램을 만들 수 있습니다. 인터프리터의 경우, 컴파일러와는 달리 소스코드에서 기계어로 변환하지 않고, 하나의 명령 단위로 수행한 결과를 바로 실행해서 결과를 확인할 수 있습니다. 보통, 컴파일된 프로그램이 인터프리터를 통해 실행하는 것보다 더 빠르게 실행됩니다. 하지만, 인터프리터는 모든 명령에 대해 컴파일이 이뤄지지 않아도 중간에 결과를 확인할 수 있다는 장점이 있습니다.
  컴파일러를 통해 하나의 프로그램을 만드는 언어를 컴파일 언어라고 하고, 인터프리터를 통해 단계적으로 실행되는 언어를 인터프리터 언어라고 합니다. 컴파일 언어의 경우, 대표적으로 C언어나 C++이 있습니다. 자바 또한 컴파일 언어지만 앞서 말한 언어와는 다르게 JVM 이라는 가상 머신에 의해 실행되기 위한 바이트코드로 변환됩니다. 인터프리터 언어로는 파이썬이나 자바스크립트가 있습니다.

## JAVA

- **자바의 특징**
  자바는 JVM위에서 실행되는 객체 지향적 프로그래밍 언어입니다. 자바는 JVM을 이용하기 때문에 운영체제에 독립적이고, 객체 지향 언어입니다. GC를 지원하여 개발자가 직접 메모리를 해제하지 않아도 된다는 장점이 있습니다.
- **자바의 장단점**
  - 장점
    - 객체 지향 프로그래밍의 장점을 충분히 반영하며, 플랫폼 종속적이지 않고 보안 및 운영 측면에서 안정적입니다.
  - 단점
    - C언어 등과 같은 네이티브 언어에 비해 실행 속도가 느리고, 많은 메모리를 사용한다는 단점이 있습니다.
- **자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**
  아니요, JVM 위에는 자바 이외의 언어도 실행할 수 있습니다. 이러한 언어는 보통 JVM 언어라고 불립니다. 몇 가지 예로는 Kotlin, Groovy 등이 있습니다.
- **일급객체란 무엇인가요? 자바는 일급객체인가요?**
  - 변수에 할당할 수 있어야 합니다.
  - 함수의 인자로 전달할 수 있어야 합니다.
  - 함수의 반환값으로 사용할 수 있어야 합니다.
  자바는 일급 객체를 지원합니다. 객체는 변수에 할당할 수 있으며, 메서드의 인자로 전달하거나 반환값으로 사용할 수 있습니다.
- **SDK란 무엇인가요?**
  SDK(Software Development Kit)는 소프트웨어 개발을 위한 도구와 라이브러리의 모음입니다. SDK는 특정 플랫폼, 프레임워크 또는 언어를 지원하고 개발자가 해당 환경에서 애플리케이션을 개발할 수 있도록 필요한 도구와 자원을 제공합니다.
  자바의 경우, Java SDK 또는 JDK(Java Development Kit)라고 불리는 SDK가 있습니다. JDK는 자바 프로그램을 개발하기 위한 핵심 도구와 라이브러리를 포함하고 있으며, 자바 컴파일러, 실행환경(JRE), 디버깅 도구, 클래스 라이브러리 등을 제공합니다. 개발자는 JDK를 사용하여 자바 애플리케이션을 개발하고 실행할 수 있습니다.
- **오토캐스팅 or 박싱과 언박싱 개념에 대해 알고 계시나요?**
  - 박싱 : 기본 타입 데이터에 대응하는 Wrapper 클래스로 만드는 동작
  - 언박싱 : Wrapper 클래스에서 기본 타입으로 변환
  - 자바에서는 자동으로 오토박싱 오토언박싱이 이루어지고 있지만, 내부적으로 추가 연산 작업이 있으므로 동일한 타입 연산이 이루어지도록 구현하는 것이 좋습니다.
- **원시타입과 참조타입이 무엇인가요?**
  원시타입은 실제 데이터값을 저장하는 타입으로, int, boolean, char 등이 있습니다.
  참조타입은 객체의 주소를 저장하는 타입으로, String, Array, Class, Interface 등이 있습니다.
  자바에서 객체는 힙 영역에 저장되는데, 참조 타입 변수는 이러한 실제 객체의 주소를 스택 영역에 저장합니다. 그리고 이러한 객체들을 사용할 때 마다 참조 타입 변수에 저장된 객체의 주소를 불러와 사용하게 됩니다.

## 접근제어자

- **자바의 접근제어자에 대해 설명해주세요.**
  접근제어자는 클래스나 멤버변수, 메소드 등의 외부에서의 접근 가능 여부를 제어하는 지시어를 의미합니다. 접근제어자를 사용함으로써 외부 객체의 무분별한 접근으로부터 내부 데이터를 보호할 수 있습니다.
  - public : 클래스, 패키지에 무관하게 모든 곳에서 접근 가능
  - protected : 같은 패키지에서의 접근 가능 + 상속받은 클래스에서도 접근 가능
  - default : 같은 패키지에서의 접근 가능
  - private : 같은 클래스 내에서만 접근 가능
- **static, final, static final의 차이에 대해 설명해주세요.**
  - static = 전역 = GC 대상 아님
    - 정적 변수, 정적 메소드, 정적 클래스를 만들 수 있는 키워드입니다. static 으로 명시된 멤버들은 heap 영역이 아닌 static 메모리 영역에 할당되어 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있다는 장점이 있습니다.
    - 객체 인스턴스를 따로 생성하지 않아도 호출할 수 있기 때문에, 유틸리티 함수를 만들거나, 변하지 않는 자주 사용하는 값, 설정 정보등을 정적 메모리에 올려 객체 생성 비용을 줄이고 싶을 때 사용합니다.
    - static 영역은 Garbage Collector의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재합니다. 따라서 static으로 정의된 멤버가 너무 많을 경우 시스템 성능에 악영향을 줄 수 있습니다.
  - final = 고정
    - 변수나 메소드 또는 클래스가 ‘변경 불가능’하도록 만드는 자바 키워드로서, final로 선언시 무조건 초기화를 해야 하며, 프로그램 실행 도중 값 수정이 불가능합니다.
    - 클래스, 메서드, 변수 등이 변하는 것을 방지하기 위하여 사용합니다. 데이터를 readOnly로 만들어, 객체 내부에서 값을 변환하거나 가공하지 않음을 선언하기 위해 사용합니다.
  - static final = 전역 고정 = 상수 선언
    - 선언한 순간 값을 할당해야 합니다.

## **JAVA 버전 별 특징**

- **LTS가 무엇인가요?**
  LTS(Long Term Support) 버전은 **장기간 동안 지속적인 지원을 제공하는 자바의 버전**입니다.
- **Java 8 의 특징에 대해 설명해주세요.**
  - 람다식을 통한 함수형 프로그래밍 가능
  - Stream API
  - 인터페이스 default 메소드
  - Optional 클래스
- **자바 람다식에 대해 설명해주세요**
  람다식이란 쉽게 말해 **메서드를 "하나의 식"으로 표현한 것**입니다. 하나의 식으로 표현하여 훨씬 간략하게 표현이 가능하게 되며, 메서드의 이름과 반환값이 없어지므로 "익명함수"라고도 합니다. JDK1.8부터 추가되었습니다.
- **Java 11 의 특징에 대해 설명해주세요.**
  1. String 메소드 추가
  2. GC 성능 개선
  3. 람다에서 로컬 변수 var 사용
- **Java 14 에서 새로 도입된 Record 클래스 타입에 대해 아시나요?**
  - Record는 14버전부터 도입되고 16부터 정식 스펙으로 포함된 타입입니다.
  - **자동으로 필드를 private final로 선언해주고, 생성자와 getter도 자동으로 생성됩니다.**
  - 대신 getter 메소드의 경우 get이 메소드명에 프리픽스로 붙지는 않습니다.

## OOP

- **객체 지향이 무엇인지에 대해 설명해주세요**
  객체 지향 프로그래밍이란 데이터를 추상화하여 상태와 행위를 지니는 객체로 만들고, 객체 간의 상호작용을 통해 로직을 구현하는 프로그래밍 방법입니다.
- **객체 지향 프로그래밍의 특징은 무엇인가요?**
  상속, 추상화, 캡슐화, 다형성의 특징을 가지고 있습니다.
  - 상속 : 자식 클래스가 부모 클래스의 기능과 상태를 물려받아 그대로 사용하거나 필요한 부분만 수정할 수 있습니다.
  - 추상화 : 객체를 추상화한 후, 필요한 객체에서 상속받아 필요에 맞게 기능을 재정의할 수 있습니다.
  - 캡슐화 : 비슷한 속성과 메소드를 하나의 클래스로 모은 것입니다. 외부 접근으로부터 데이터를 지킵니다.
  - 다형성 : 같은 이름을 가지더라도 다른 기능을 구현할 수 있도록 합니다. 오버로딩과 오버라이딩, 인터페이스와 관련된 특징입니다.
- **객체 지향 프로그래밍의 5가지 원칙에 대하여 알고 계시나요?**
  - **SRP 단일 책임 원칙** : 객체는 하나의 책임만을 가져야 합니다.
  - **OCP 개방-폐쇄 원칙** : 확장에는 열려 있고, 변경에는 닫혀 있어야 합니다.
  - **LSP 리스코프치환 원칙** : 객체는 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 합니다.
  - **ISP 인터페이스 분리 원칙** : 하나의 범용 인터페이스보다 여러 개의 인터페이스가 더 좋다.
  - **DIP 의존관계 역전 원칙** : 추상화에 의존하고, 구현체에 의존하면 안된다.
- **객체 지향 프로그래밍의 장단점은 무엇인가요**
  장점
  - 객체를 이용하여 코드 재사용이 용이하고, 상속을 통한 확장이 가능합니다.
  - 모듈화 등을 통해 유지보수와 분업에 좋습니다.
  단점
  - 객체가 많을 수록 용량이 커지고, 올바르게 설계하는 데에 많은 노력과 시간이 필요합니다.
- **클래스, 객체, 인스턴스의 차이**
  - 클래스: JVM 메모리의 클래스 영역(Class Area)에 로드되는 일종의 설계도
  - 객체: 자기 고유의 속성을 가지며 다른 것과 식별 가능한 모든 대상
  - 인스턴스: 힙 영역(Heap Area)에 생성된 클래스의 실체
- **캡슐화와 은닉화의 차이?**
  캡슐화는 클래스 내부적으로는 응집도를 높이고, 외부적으로는 의존도나 결합도를 낮추는 것을 의미합니다. 은닉화는 클래스의 중요정보를 밖으로 드러나지 않도록 은닉하는 것입니다. 둘은 다른 개념이지만, 캡슐화를 하면 내부 정보를 감출 수 있으므로 정보 은닉의 효과가 있습니다.
- **Overloading과 Overriding의 차이**
  - 오버로딩이란 같은 이름을 가지는 메소드를 여러 개 가지는 것을 의미합니다. 메소드의 이름은 같지만 매개변수의 타입, 개수, 반환타입 등을 다르게 하여 재정의할 수 있습니다.
  - 오버라이딩이란 부모 클래스로부터 상속받은 메소드를 재정의하여 사용하는 것을 의미합니다. 필요한 부분만 재수정하여 원하는 기능으로 구현합니다.
- **Overloading과 Overriding의 장점과 사용예시에 대해 말해주세요.**
  - 오버로딩
    - 메소드 이름 1개로 여러 기능을 재정의할 수 있으므로 가독성이 좋아진다는 이점이 있습니다.
    - 오버로딩은 생성자가 여러개 필요한 경우 유용합니다.
  - 오버라이딩
    - 기능 확장에 이점이 있고,
    - 클래스 간 결합도를 낮추기 위한 방법 중 하나로 interface를 사용할 때 오버라이딩을 사용합니다.

## 추상 클래스와 인터페이스

- **인터페이스와 추상클래스의 차이가 무엇인가요?**
  두 차이는 존재 목적에 있습니다. 추상 클래스는 그 추상 클래스를 상속 받아 기능을 이용하고, 확장시키는 데에 있는 반면, 인터페이스는 해당 기능의 구현을 강제하기 위해 존재합니다. 구현을 강제함으로써 구현 객체의 같은 동작을 보장할 수 있습니다.
- **인터페이스와 추상클래스의 구현 부분에서 어떤 차이가 있나요?**
  - 인터페이스는 다중 상속을 지원하고 변수를 가질 수 없습니다. 모든 메소드는 선언만 할 수 있고 구현 클래스에서 모든 메소드를 오버라이딩 해야 합니다.
  - 추상클래스는 단일 상속만 지원하고, 변수를 가질 수 있습니다. 추상 메소드를 구현할 수 있습니다.
  - Java 버전이 올라갈수록 둘의 차이가 미미해지고 있습니다. 인터페이스에서도 default 혹은 private method를 사용할 수 있습니다.
- **인터페이스에서 default method를 사용할 수 있도록 변경된 이유가 무엇일까요?**
  객체지향 설계 5원칙 중 OCP(개방 폐쇄 원칙)와 관련이 있습니다. 개방 폐쇄 원칙이란 “확장에는 열려 있으나 변경에는 닫혀 있어야 한다.”는 원칙인데, 특정 인터페이스에 메소드가 하나 추가될 때마다, 해당 인터페이스를 상속받은 모든 구현 클래스에서 이 메소드를 사용하지 않더라도 구현해야 하므로 이는 OCP 원칙을 지켰다고 보기 어렵습니다.
  따라서 default method를 추가하여 구현을 강제하지 않을 수 있습니다.
- **default method를 사용하다가 충돌이 발생하면 어떡하죠?**
  default method도 마찬가지로 구현 클래스에서 오버라이딩하여 재정의할 수 있습니다.
- **추상 클래스와 인터페이스의 차이점을 바탕으로 어떤 상황에 어떤 것이 더 적합한지 설명해주세요.**
  - 공통된 동작이 있고, 그 외의 부분을 자식 클래스에서 확장하여 사용하기 위해선 추상클래스가 적합하고
  - 각 클래스들이 모두 동일한 목적을 가지는 동작을 공유하고, 다중상속이 필요하다면 인터페이스가 적합합니다.
  - 하지만 Java 버전이 올라감에 따라 인터페이스가 추상클래스의 역할을 흡수하고 있으므로, 인터페이스로 구현하는 것이 적합할 것 같습니다.
- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**
  다중 상속을 허용하게 된다면, 다양한 문제를 발생시킬 수 있습니다. 예를 들어 A클래스가 B, C 클래스를 다중 상속하는데 B, C 클래스에서 같은 이름의 메서드나 속성을 사용한다면, A클래스가 어떤 메서드나 속성을 사용해야할지 모호해집니다.
  인터페이스는 이러한 다중 상속의 문제를 해결하기 위하여 도입되었는데, 메서드의 명세만 정의하고 실제 구현을 제공하지 않기 때문에 여러 인터페이스의 특성을 동시에 가져갈 수 있고 다중 상속의 문제를 피할 수 있습니다.

## GC(Garbage Collector)

> JVM 메모리 구조, 특히 Heap Area에 대한 이해가 필요

- **GC란 무엇인가요?**
  GC(Garbage Collector)는 JVM 메모리를 재활용하기 위해 더이상 참조되지 않는 객체를 자동으로 메모리에서 제거해주는 모듈입니다. 이는 메모리 누수를 방지하고, 프로그램의 효율적인 메모리 사용을 돕습니다.
- **GC의 장단점에는 무엇이 있나요?**
  - 장점
    - 자동으로 메모리를 관리해주기 때문에 개발자가 직접 메모리를 관리하지 않아도 되므로 개발 속도가 빨라집니다.
  - 단점
    - 더이상 참조되지 않는 객체를 확인하기 위해 Mark and Sweep 과정을 거치는데 이때 스레드를 잠시 멈춥니다(stop the world). 이로 인해 오버헤드가 발생하고 따라서 성능이 떨어지는 단점이 있습니다.
- **GC의 단점을 개선하기 위해서 무엇을 할 수 있을까요?**
  - 효율적으로 GC를 실행하는 알고리즘 최적화 작업이 필요합니다. 흔히 GC튜닝이라고 하고, 다양한 알고리즘이 고안되어 왔습니다.
- **GC가 관리하는 JVM의 Heap 메모리 구조에 대해 설명해주세요.**
  Heap 영역은 크게 3가지 영역으로 나뉩니다.
  - 1. Young Gen.
    - 새롭게 생성한 객체가 위치하는 영역
    - Young 영역에 대한 가비지 컬렉션을 Minor GC라고 부릅니다.
  - 2. Old Gen.
    - Young 영역에서 살아남은 객체가 이동하는 영역으로, Young 영역보다 메모리가 크고 따라서 GC는 더 적게 발생합니다.
    - Old 영역에 대한 가비지 컬렉션을 Major GC 혹은 Pull GC라고 부릅니다.
  - 3. Permanent Gen.
    - OS 레벨에서 관리하는 메모리 영역으로, classpath 등 class의 메타데이터를 저장하는 영역입니다.
    - 이 영역은 Java7까지는 Heap 영역에 존재했으나, Java8부터는 Native Method Stack 영역에 편입되었습니다.
- **Young 영역에서 Old 영역으로 객체가 이동하는 과정을 설명해 주세요.**
  - 새롭게 생성한 객체는 Young 영역의 Eden 영역에 위치하다가, eden영역이 가득 차면 Minor GC가 발생합니다. 이때 살아남은 객체는 Survivor 영역으로 이동하고 age가 증가합니다.
  - 이 과정을 반복하다가 age가 임계값을 넘은 객체들이 Old 영역으로 이동합니다. 이 이동을 promotion이라고 부릅니다.
- **Minor GC와 Major GC의 차이점**
  - Minor GC는 Young 영역 중 Eden 영역이 가득찰 때 발생하고, Major GC는 Old 영역 전체를 대상으로 발생합니다.
  - Minor GC는 1초 이내로 끝나므로 애플리케이션에 크게 영향을 주지 않지만, Major GC의 경우 10배 이상의 시간이 소요됩니다. 따라서 이를 개선하기 위한 다양한 GC알고리즘이 고안되어 왔습니다.
- **GC 알고리즘의 종류**
  - Serial GC
  - G1 GC
  - Parallel GC
  - Parallel Old GC
  - CMS GC
- **finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?**
  finalize() 메서드는 객체가 GC에 의해 제거되기 전에 호출됩니다. 수동으로 호출하는 것은 GC 프로세스를 방해하고, 예기치 않은 동작이나 메모리 누수를 야기할 수 있으므로 피해야 합니다.
- **어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?**
  변수의 값이 null이 된다고 해서 그 값이 자동으로 GC의 대상이 되는 것은 아닙니다. GC는 더 이상 참조되지 않는 객체를 판단하여 메모리에서 해제합니다. 변수의 값이 null이 된다면, 해당 변수는 더 이상 객체를 참조하지 않는 것으로 간주될 수 있지만, 다른 변수나 데이터 구조에서 여전히 참조하고 있다면 GC 대상이 아닙니다.

## Thread, 동기화

- **스레드의 상태에는 무엇이 있나요?**
  스레드의 상태는 5가지가 있습니다.
  - **NEW** : 스레드가 생성되고 아직 start()가 호출되지 않은 상태
  - **RUNNABLE** : 실행 중 또는 실행 가능 상태
  - **BLOCKED** : 동기화 블럭에 의해 일시정지된 상태(lock이 풀릴 때까지 기다림)
  - **WAITING, TIME_WAITING** : 실행가능하지 않은 일시정지 상태
  - **TERMINATED** : 스레드 작업이 종료된 상태
- **자바에서의 스레드 구현 방법은 무엇이 있나요?**
  - 자바에서 스레드를 구현하는 방법에는 2가지 방법이 있습니다.
    1. **Runnable 인터페이스 구현**
       1. Runnable 인터페이스를 구현한 경우는, 해당 클래스를 인스턴스화해서 Thread 생성자에 argument로 넘겨줘야 한다.
    2. **Thread 클래스 상속**
       1. Thread 클래스를 상속받은 경우는, 상속받은 클래스 자체를 스레드로 사용할 수 있다.
- **스프링부트에서 멀티스레드를 구현하려면 어떻게 하면 되나요?**
  프로젝트 어플리케이션 클래스에 @EnableAsync 어노테이션을 붙이고, 비동기를 원하는 메소드에 @Async 어노테이션을 붙입니다. 단 이때 @Async 어노테이션이 붙으면 스레드를 재사용하지 않고 매번 새로운 스레드를 생성합니다. 따라서 스레드풀 관리를 하기 위해선 Config 클래스를 생성하여 추가 설정을 해 주어야 합니다.
- **멀티스레드에서 동기화가 중요한 이유는 무엇인가요?**
  여러 스레드가 같은 프로세스 내의 자원을 공유하면서 작업할 때 서로의 작업이 다른 작업에 영향을 주기 때문입니다. 스레드의 동기화를 위해선, 임계 영역(critical section)과 잠금(lock)을 활용합니다.
- **싱글스레드 환경이라면 동기화에 의한 오버헤드가 발생하지 않을까요?**
  싱글스레드에서는 한 번에 하나의 명령어만 실행하기 때문에 경쟁 상태(race condition)나 교착 상태(deadlock) 같은 문제가 발생할 여지가 없지만 락을 거는 데에는 어느 정도의 자원이 소모되므로 미미한 오버헤드가 발생할 수 있을 것 같습니다.
- **자바에서 임계영역을 설정하는 방법에 대해 설명해주세요.**
  서로 다른 두 객체가 동기화를 하지 않은 메소드를 같이 오버라이딩해서 이용하면, 두 스레드가 동시에 진행되므로 원하는 출력 값을 얻지 못합니다. 이때 오버라이딩되는 부모 클래스의 메소드에 synchronized 키워드로 임계영역을 설정해주면 해결할 수 있습니다.
- **Thread safe 개념이란?**
  멀티 쓰레드 프로그래밍에서, 어떤 공유 자원에 여러 쓰레드가 동시에 접근해도, 프로그램 실행에 문제가 없는 상태를 의미합니다.
- **Vector와 ArrayList의 차이를 아시나요?**
  - Vector : 동기식. 한 스레드가 벡터 작업 중이면 다른 스레드가 벡터 보유 불가능. Thread-safe O.
  - ArrayList : 비동기식. 여러 스레드가 ArrayList에서 동시 작업이 가능. Thread-safe X
- **HashMap, HashTable, ConcurrentHashMap의 차이?**
  HashMap은 동기화를 보장하지 않고, null을 허용합니다.
  반면 HashTable과 ConcurrentHashMap은 둘 다 동기화를 보장하는데, 동기화 구현 방식과 그에 따른 성능이 조금 다릅니다. HashTable은 메서드 전체에 락을 걸고, ConcurrentHashMap은 부분적으로 락이 걸리므로 성능 면에서 ConcurrentHashMap이 더 빠릅니다.

## Error vs Exception

> Error와 Exception의 차이점에 대해 설명할 수 있다.
>
> Exception Handling을 할 수 있다.

- **Error와 Exception의 차이를 설명해주세요**
  - **Error**: Error는 프로그램 실행 중의 복구할 수 없는 심각한 문제를 나타내며, 주로 시스템 레벨의 문제를 가리킵니다. 예를 들어, OutOfMemoryError은 메모리 부족으로 인해 프로그램이 중단되는 경우입니다. Error는 보통 애플리케이션 코드에서 처리하지 않고, 시스템 레벨에서 처리됩니다. Error의 상황을 미리 미연에 방지하기 위해서 Exception 상황을 만들 수 있습니다.
  - **Exception**: Exception은 프로그램 실행 중에 발생할 수 있는 예외 상황을 나타냅니다. 예외는 주로 프로그램 내부 또는 외부 요인에 의해 발생하며, 예외를 처리하고 프로그램의 정상적인 흐름을 유지하기 위해 예외 처리 코드를 사용합니다. 예외는 Checked Exception과 Unchecked Exception으로 나눌 수 있습니다.
- **Unchecked Exception과 Checked Exception의 차이점은 무엇인가요?**
  - **Checked Exception (컴파일타임 예외)**: 컴파일러가 체크하는 예외로, 반드시 예외 처리를 해야 합니다. 예외를 처리하지 않으면 컴파일 오류가 발생합니다. Checked Exception은 RuntimeException 클래스를 상속하지 않는 예외 클래스들을 말합니다. 대표적인 예로는 IOException, SQLException 등이 있습니다.
  - **Unchecked Exception (런타임 예외)**: 컴파일러가 체크를 하지 않는 예외입니다. 주로 프로그래머의 실수에 의한 예외나 더 이상 복구할 수 없는 예외 상황을 나타냅니다. Unchecked Exception은 RuntimeException 클래스 및 그 하위 클래스들로 대표됩니다. 대표적인 예로는 NullPointerException, ArrayIndexOutOfBoundsException 등이 있습니다.
- **Exception Handling 방법을 설명해주세요.**
  자바에서 예외를 처리하는 방법에는 크게 2가지가 있습니다.
  1. 직접 try ~ catch 를 이용해서 예외에 대한 최종적인 책임을 지고 처리하는 방식
  2. throws Exception 을 이용해서 발생한 예외의 책임을 호출하는 쪽이 책임지도록 하는 방식 (주로 호출하는 쪽에 예외를 보고할 때 사용합니다.)

## Generic

- **Generic이란 무엇인가요?**
  - 제네릭이란 클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것입니다. 해당 객체의 데이터타입이 컴파일 시 결정됩니다.
- **Generic의 장점은 무엇인가요? 왜 사용하나요?**
  1. 제네릭을 사용하면 잘못된 타입이 들어오는 것을 컴파일 단계에서 방지할 수 있습니다.
  2. 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없으므로 관리가 편합니다.
  3. 다른 클래스 타입에 대해 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아집니다.
- **Generic 타입을 제한하기 위해 사용하는 것은 무엇인가요?**
  **extneds와 super 그리고 ?** 입니다.
  ```java
  <K extends T> // T와 T의 자손 타입만 가능(K는 들어오는 타입으로 지정 됨)
  <K super T> // T와 T의 부모(조상) 타입만 가능(K는 들어오는 타입으로 지정됨)
  <? extends T> // T와 T의 자손 타입만 가능
  <? super T> // T와 T의 부모 타입만 가능
  <?> // 모든 타입 가능. <? extends Object>랑 같은 의미
  ```

## 불변객체

> mutation(가변), immutation(불변) 이해
> 불변객체인 String 의 연산에서 오는 퍼포먼스 이슈 이해

- **불변객체란 무엇인가요?**
  불변객체(immutable object)는 생성 후 그 상태를 바꿀 수 없는 객체를 말합니다. 반대 개념인 가변객체(mutable object)는 생성 후에도 상태를 변경할 수 있습니다.
  즉, 불변객체는 재할당은 가능하지만, 한번 할당하면 내부 데이터를 변경할 수 없는 객체입니다. 자바의 대표적인 불변객체로는 String이 있습니다.
- **불변객체는 왜 사용하는 걸까요? 불변객체의 장단점에 대해 말해주세요.**
  장점
  - 객체에 대한 신뢰도가 높아집니다. 객체가 한번 생성되어서 그게 변하지 않는다면 transaction 내에서 그 객체가 변하지 않기에 우리가 믿고 쓸 수 있기 때문입니다.
  - 생성자, 접근메소드에 대한 방어 복사가 필요하지 않습니다.
  - 멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있습니다.
  단점
  - 객체가 가지는 값마다 새로운 객체가 필요합니다. 따라서 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능저하를 발생시킬 수 있습니다.
- **Java로 불변객체를 만드는 방법이 있을까요?**
  - 필드에 final을 사용하고, Setter를 구현하지 않는 방식으로 불변객체를 구현할 수 있을 것 같습니다. 이때 모든 필드가 원시 타입이어야 하고, 참조 타입일 경우 추가적인 작업이 필요합니다.
    - 1. 참조하고 있는 타입 또한 불변객체여야 합니다.
    - 2. Array나 List의 경우 생성자에서 해당 배열/리스트를 그대로 사용하는 것이 아닌 복사해서 저장합니다.
- **String, String Builder, String Buffer 차이에 대해 알고 계신가요?**
  - **String**
    - 불변객체
    - 연산 과정에서 불변객체의 반복 생성으로 성능이 낮음
  - **String Builder**
    - 가변, 비동기
    - 동기화를 지원하지 않으므로 Thread-safe하지 않지만 싱글스레드 환경에서 속도가 빠름
  - **String Buffer**
    - 가변, 동기
    - 동기화를 지원하므로 Thread-safe하지만 속도가 느림
- **왜 String은 불변객체일까요?**
  - 1. 보안
    - String은 Port, 경로 등 민감한 정보를 저장하는 데에 많이 사용되므로 변경 불가능하도록 하여 값이 변경되지 않도록 합니다.
  - 2. 캐싱
    - String은 hashCode() 메소드가 자주 사용되는데, 이때 캐싱이 가능하도록 하기 위함입니다.
  - 3. 성능
    - String Constant Pool에서 관리를 하여 Heap 영역의 메모리를 절약할 수 있습니다. 같은 값에 대해서는 String 객체를 다시 만들지 않고 이미 존재하는 객체를 참조할 수 있기 때문입니다.
  - 4. 동기화
    - 불변객체는 값이 바뀌지 않으므로 멀티스레드 환경에서 Thread-safe하다는 장점이 있습니다.
- **Call By Value와 Call By Ref의 차이는 무엇인가요? 자바는 둘 중 무엇인가요?**
  - Call By Value
    - 함수 호출 시 전달되는 변수값을 복사해서 함수 인자로 전달합니다. 즉, 함수가 호출될 때 메모리 내에서 함수를 위한 별도의 임시공간이 생성됩니다.
    - 따라서 함수 안에서 인자 값이 변경되더라도, 외부 변수 값은 변경되지 않습니다.
  - Call By Ref
    - 함수 호출 시 인자로 전달되는 변수의 레퍼런스를 전달합니다. 즉, 함수 안에서 인자 값이 변경되면, 아규먼트로 전달된 객체의 값도 변경됩니다.
  - 자바의 경우 항상 Call By Value로 값을 넘깁니다. 레퍼런스 타입의 자료형을 넘길 때에는 해당 객체의 주소값을 복사하여 이를 사용합니다. 따라서 원본 객체의 프로퍼티까지는 접근이 가능하지만, 원본 객체 자체를 변경할 수는 없습니다.
- **new String()과 리터럴방식(””)의 차이를 아시나요?**
  - new 연산자를 사용하여 String을 생성하게 되면 객체로 생성이 되어 Heap메모리 영역에 저장이 되고, 리터럴(literal)을 사용하여 String을 생성할 경우 String constant pool이라는 영역에 생성이 됩니다.
  - 따라서 new 연산자를 사용하는 방식은 메모리를 낭비하는 방식입니다.
- **equals과 ==의 차이가 무엇인가요?**
  equals는 값 자체를 비교하고, ==는 메모리상 동일한 객체인지 주소값을 비교합니다.

## Composition (컴포지션)

- **컴포지션이란 무엇인가요? 상속과 컴포지션의 개념에 대해 알고 계신가요?**
  - 컴포지션은 클래스 간 상속의 단점을 해결하기 위해 나온 개념으로, 클래스를 확장하는 것이 아니라 새로운 클래스가 private 필드로 다른 클래스 객체의 인스턴스를 자신의 인스턴스 변수로 참조하도록 하는 방식입니다. 이를 forwarding이라고 합니다.
  - 해당 인스턴스의 내부 구현이 바뀌더라도 영향을 받지 않는다.
  - 또한, 다른객체의 인스턴스이므로 인터페이스를 이용하면 Type을 바꿀 수 있다.
- **클래스 간 상속의 단점은 무엇인가요?**
  상속은 코드를 재사용할 수 있는 강력한 수단이지만, 클래스간 상속은 잘못 사용하면 객체의 유연성을 해치는 결과를 초래할 수도 있습니다. 왜냐하면 상속은 1) 캡슐화를 위반하고, 2) 설계에 유연하지 않으며, 3) 다중 상속이 불가능하기 때문입니다.
  - 1. 캡슐화 위반
    - 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있음
    - 상위 클래스의 내부 구현이 달라지면 하위 클래스를 고쳐야 할 수도 있음
  - 2. 설계의 비유연성
    - 컴파일 시점에 객체의 Type이 정해짐
  - 3. 다중상속 불가능
- **그럼 언제 상속을 하고 언제 컴포지션을 하면 좋을까요?**
  - 상위 클래스와 하위 클래스가 is-a 관계일 때 상속을 사용하면 좋습니다. 즉 OOP 5가지 원칙 SOLID 중 리스코프 치환 원칙에 유배되지 않을 때 상속을 사용합니다.
  - 반대로 has-a 관계라면 컴포지션을 사용한 설계를 고려해보는 것이 좋을 것 같습니다.]
  - 개인적으로는 추후 확장성이나 유지보수적 측면에서 명확한 is-a 관계 성립을 보장하기가 어려울 것 같아서, 컴포지션 방식을 사용하는 것이 유연한 객체 지향적 설계가 아닐까 생각합니다.

## Stream

- **Collection과 Stream의 차이는 무엇인가요?**
  **Collection**
  - 모든 값을 메모리에 저장합니다. 따라서 Collection에 추가하기 전에 미리 계산이 되어있어야 합니다.
  - 외부 반복을 통해 사용자가 직접 반복 작업을 거쳐 요소를 가져올 수 있습니다.(for-each)
  **Stream**
  - 요청할 때만 요소를 계산합니다. 내부 반복을 사용하므로, 추출 요소만 선언해주면 알아서 반복 처리를 진행합니다.
  - 스트림에 요소를 따로 추가 혹은 제거하는 작업은 불가능합니다.
- **대표적인 Stream 메서드를 말해주세요.**
  - map()
  - filter()
  - collect()
